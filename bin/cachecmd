#!/bin/bash

# A bit complex & was created by alan.
# Basically, this will cache the output of a command for a given amount of time.
# So the command will sometimes run and sometimes not run.
# To force the command to run, set the environment variable "CACHECMD_CLEAR" to any value.
# Duration defaults to days, but can have other time endings too: smhdw
# cachemd DURATION CMD ARGS...
#
[ "$#" -lt 2 ] && echo 'USAGE: cachecmd <duration> <cmd> [<arg>...]'

CACHE_DIR=${CACHECMD_DIR:-${XDG_CACHE_HOME:-/tmp}}/cachecmd
DURATION=$1
FILE=${CACHE_DIR}/$(argshash "${@:2}")

if [[ $(find $FILE -mtime -${DURATION} 2>/dev/null) ]] && [[ -z "$CACHECMD_CLEAR" ]]; then
    [[ -n "$CACHECMD_DEBUG" ]] && echo '[cachecmd] cache mode' >&2
    cat < "$FILE"
else
    [[ -n "$CACHECMD_DEBUG" ]] && echo '[cachecmd] command mode' >&2
    mkdir -p "$CACHE_DIR"
    "${@:2}" | tee "$FILE"
fi

# # Proof of concept for cachecmd with ax shell.
# a cachecmd ^EOF
#     $CACHE_DIR [!if (test -n {CACHECMD_DIR}) {CACHCMD_DIR} [!if (test -n {XDG_CACHE_HOME}) {XDG_CACHE_HOME} -/tmp]]/cachecmd
#     $CACHE_DIR [or {CACHECMD_DIR} {XDG_CACHE_HOME} /tmp]/cachecmd
#     $DURATION {1}
#     $FILE {CACHE_DIR}/(argshash *[range '2:' *{@}])
# 
#     !if (!and (find {FILE} -mtime -{DURATION} 2>/dev/null) (test -z {CACHECMD_CLEAR}))
#         [
#             (!if (test -n {CACHECMD_DEBUG}) [echo '[cachecmd] cache mode'])
#             cat -- {FILE}
#         ][
#             (!if (test -n {CACHECMD_DEBUG}) [echo '[cachecmd] command mode'])
#             mkdir -p {CACHE_DIR}
#             [range '2:' *{@}] | tee {FILE}
#         ];
# EOF
