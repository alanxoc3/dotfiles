#!/bin/bash
# alias
alias a='alias'

extension() { [[ $1 =~ '\.' ]] && recho "${@##*.}" }
filebasename() { basename $1 | cut -f 1 -d '.' }
abs() { echo "$(cd "$(dirname "$1")" && pwd -P)/$(basename "$1")" }

# https://unix.stackexchange.com/questions/159253/decoding-url-encoding-percent-encoding
alias urlencode='python3 -c "import urllib.parse, sys; print(urllib.parse.quote(\" \".join(sys.argv[1:]) if len(sys.argv) > 1 else sys.stdin.read()[0:-1]))"'
alias urlencodeplus='python3 -c "import urllib.parse, sys; print(urllib.parse.quote_plus(\" \".join(sys.argv[1:]) if len(sys.argv) > 1 else sys.stdin.read()[0:-1]))"'
alias urlencodeslash='python3 -c "import urllib.parse, sys; print(urllib.parse.quote(  \" \".join(sys.argv[1:]) if len(sys.argv) > 1 else sys.stdin.read()[0:-1], \"\"))"'
alias urldecode='python3 -c "import urllib.parse, sys; print(urllib.parse.unquote(\" \".join(sys.argv[1:]) if len(sys.argv) > 1 else sys.stdin.read()[0:-1]))"'

# hex string to int:
# python -c 'import sys; print(int(sys.stdin.read(), 16))'

# diff -u f1 f2 | diff-so-fancy
# remove duplicates no sorting.
# awk '{ if (a[$0] == 0){ a[$0] += 1; print $0} else {print "NULL";}}'

# Get the fingerprint of an ssh private key (useful for aws).
# openssl pkcs8 -in <path_to_private_key> -inform PEM -outform DER -topk8 -nocrypt | openssl sha1 -c

# increment git tag
# git tag | sort -V | tail -n 1 | awk -vFS=. -vOFS=. '{$NF++;print}'

# Adding ogg meta-data
# vorbiscomment -w -t 'ARTIST=alan@xoc3.io' -t 'ALBUM=piano-tunes' -t 'TITLE=canon theme' canon_theme.ogg
# vorbiscomment canon_theme.ogg

# Show if airplane mode is on or off
# rfkill list all

# create midi connection:
# timidity -iA
# aconnect <send-midi> <receive-midi>

# create short github url
# curl -i https://git.io -F "url=<github-url>"

# cli_yt installation:
# pacman -S libcaca                       # needed for ascii video driver
# yay mpv-git                             # needed for yt-dlp default & libcaca built-in integration
# python3 -m pip install --upgrade yt-dlp # youtube-dl is too laggy now and not maintained as much

# waitexecquiet
waitexecq() {
    (&>/dev/null nohup bash -c "sleep $1; ${@:2}" &)
}

waitexec() {
    (bash -c "sleep $1; ${@:2}" &)
}

mpv_cli_mute() {
    [ "$#" -lt 1 ] && echo "USAGE: $0 <mpv-options>..." && return 1
    CACA_DRIVER=ncurses mpv --no-terminal --aid=no -vo caca "$@"
}

mpv_cli() {
    [ "$#" -lt 1 ] && echo "USAGE: $0 <mpv-options>..." && return 1
    CACA_DRIVER=ncurses mpv --no-terminal -vo caca "$@"
}

# cats files to a destination, then shreds & rms them.
mvcat() {
    cat "${@:1:${#@}-1}" >> "${@:${#@}}"
    command -v shred &>/dev/null && shred "${@:1:${#@}-1}"
    rm "${@:1:${#@}-1}"
}

# cats files to stdout, then shreds & rms them.
rmcat() {
    cat "${@:1:${#@}}"
    command -v shred &>/dev/null && shred "${@:1:${#@}}"
    rm "${@:1:${#@}}"
}

multiqr() {
    [ "$#" -ne 2 ] && echo "USAGE: echo x | multiqr DIRNAME MAX_BYTES" && return 1
    tempdir=$(mktemp -d)
    pushd "$tempdir" > /dev/null
    cat > original_file
    char_count=$(cat original_file | wc -m)
    cat original_file | split -b $(calc_partition "$char_count" $2)
    rm original_file
    for file in $(ls); do
        cat $file | qrencode -o $file.png
        shred $file
        rm $file
    done
    popd > /dev/null
    mv "$tempdir" "$1"
}

# A poor vpn
a pvpn="sshuttle -r work 0/0 -x work.xoc3.io"

check_dns_a_record() {
    dig +short $1
}

check_rdns() {
    dig -x $(check_dns_a_record $1) +short
}

# renaming user: https://linuxtechlab.com/rename-user-in-linux-rename-home-directory/
# pkill -u $old_username # (end running sessions)
# usermod -l $new_username $old_username
# usermod -d /home/$new_username -m $new_username
# groupmod -n $new_username $old_username

# https://www.jvt.me/posts/2019/12/04/openssl-certs-dir-setup/

# Returns the PEM-like certificate from https thing
# USAGE: domain port
get_ssl_cert() {
    openssl s_client -connect "$1:${2:-443}" 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'
}

parse_ssl_cert() {
    openssl s_client -connect "$1:${2:-443}" 2>/dev/null </dev/null | openssl x509 -inform pem -noout -text
}

# gemini
a am='amfora'
ams() { amfora "gemini://geminispace.info/search?$(urlencode $@)" }
a ama='amfora warmedal.se/~antenna/'
a amx='amfora xoc3.io'

# host name then path
cgem() { echo "gemini://$1/$2" | ncat -C --ssl "$1" 1965 }

# qrdecode
qrdecode='zbarimg --raw -q'

# update files
a ua='unalias -a; source ~/.aliases 2> /dev/null; source ~/.local_aliases 2> /dev/null'
a uz='unalias -a; source ~/.zshenv 2> /dev/null;  source ~/.zshrc 2> /dev/null'

# mount
a mone="sudo mount /dev/sda1 /mnt"
a mountmicrosd=mountcard
a mountsdcard=mountcard
a mtwo="sudo mount /dev/sdb1 /mnt2"
a umnt='sudo umount /mnt'
a umone="sudo umount /mnt"
a umtwo="sudo umount /mnt2"

# git
# Interesting article: https://redfin.engineering/visualize-merge-history-with-git-log-graph-first-parent-and-no-merges-c6a9b5ff109c
# Interesting git log options from that article: git log --pretty="format:%h %ar %s" --no-merges --first-parent --graph

# use filter-repo to remove a file from history
# git filter-repo --path <absolute-path-of-file-from-base-dir> --invert-paths --force

a repos='cd ~/repos'
a rep=repos
a cg='cd $(git rev-parse --show-toplevel)'
a gs='git status'
a gst='git stash'
a g='git'
a gsi='git submodule init'
a gsu='git submodule update'
a gu='git pull'
a gf='git fetch'
a ga='git add'
a gaa='git add --all'
a gr='git rebase'
a gra='git rebase --abort'
a grc='git rebase --continue'
a gc='git add --all; git commit;'
a gca='git add --all; git commit --amend;'
a grh='git reset --hard'
a gcl='git clone'
a gm='git merge'
a gmf='git merge --ff-only'
a gp='git push'
a gpf='git push --force'
a gpn='git push -u origin $(git branch --show-current)'
a gpd='git push origin --delete $(git branch --show-current)'
a gl='git log --show-signature'
a glo="gl --pretty='%h %ad %an: %s%d' --date=short"
a gla="glo --all --graph"
a glf="gl --name-status --find-renames --oneline"
a gd='git diff'
a gdc='git diff --cached'
a gdf='git diff --name-only'
a gt='git tag'
a gb='git branch'
a gbd='git branch -D'
a gbdr='git push origin --delete'
a gba='git branch --all'
a gpa='git push --all origin'
a gbc='git branch --show-current'
a gk='git checkout'
a gk-='git checkout -'
a gkb='git checkout -b'
a gkt='git checkout --track'
a gbl='git blame'
a gwl='git worktree list'
gwa() { git worktree add "$HOME/work/$1" }
gwr() { git worktree remove --force "$HOME/work/$1" }
a gitsvnignore='git svn show-ignore >> .git/info/exclude'

# git list cases
# First parameter is where you are merging into.
# Second parameter is your feature branch. Optional if you are already checked out there.
glc() {
    git log $1..$2 --oneline | grep -io1 '\([A-Za-z]\+-\d\+\)' | sort -u | sed ':a; N; $!ba; s/\n/, /g'
}

# github
a ghi='gh issue'
a ghil='gh issue list'

a chiptune='mpv_category   webradio/chiptune   75 http://79.120.11.40:8000/chiptune.ogg'
a smolfm='mpv_category     webradio/smolfm     75 http://jdj.golf:8000/radio.mp3'
a anonradio='mpv_category  webradio/anonradio  75 http://anonradio.net:8000/anonradio'
a tilderadio='mpv_category webradio/tilderadio 75 https://azuracast.tilderadio.org/radio/8000/radio.ogg'
a book='mpv_category       book                75'
a anonsched="curl https://anonradio.net/schedule/ 2> /dev/null | k -f 'spre>|^$<ret><a-x>d'"

chipbook() {
    tmux split-window mpv_category webradio/chiptune 35 http://79.120.11.40:8000/chiptune.ogg
    mpv_category book 100 "$@"
}

a getvid="youtube-dl -f 18"
a vid2mp3='youtube-dl --extract-audio --audio-format mp3'

# golang
a gocover='go test -coverprofile=/tmp/cover.out; go tool cover -html=/tmp/cover.out'

# vim & kak
a vor='kak ~/sync/library/dicts/esperanto_dictionary.txt'
a k="kak"
a editsnips="kak ~/.dotfiles/snips/*"
a es='editsnips'
a ek='kak ~/.config/kak/kakrc'
a ea='kak ~/.aliases ~/.local_aliases'
a eb='kak ~/repos/capsule/cap/blog/$(date -u +%F).gmi'
a ez='kak ~/.zshrc ~/.zshenv ~/.dotfiles/local_zshrc ~/.dotfiles/zbindings'

# diary
a diary='cd ~/sync/alan/diary'
a di='diary'
a jrn='kak ~/sync/alan/diary/{2022_diary,schedule,achievements,todos}.md'
a rnj='jrn'
a nrj='jrn'
a njr='jrn'
a tl='jrn'
a rjn='jrn'
a jnr='jrn'

# acpi
a acip=acpi
a piac=acpi
a paci=acpi
a ipca=acpi
a ipac=acpi
a paic=acpi
a pcai=acpi
a pcia=acpi
a pica=acpi
a aicp=acpi
a aipc=acpi
a apci=acpi
a apic=acpi
a iacp=acpi
a cpai=acpi
a cpia=acpi
a cpi=acpi
a ciap=acpi
a cipa=acpi
a caip=acpi
a capi=acpi
a iapc=acpi
a icap=acpi
a icpa=acpi
a acp=acpi
a ac=acpi

# docker
did() { docker ps | grep "$1" | cut -d ' ' -f1 }
dl() { docker logs $(did $1) }
dsh() { docker exec -it "$1" /bin/sh }
dbash() { docker exec -it "$1" /bin/bash }
dzsh() { docker exec -it "$1" /bin/zsh }
a dka='docker kill $(docker container ls -q)' # Kill all running containers.
a dkl='docker kill $(docker ps | awk "{print \$1;}" | tail -n 1)' # Kill first container.
a dps='docker ps'
a db.='docker build .'

# gui
a i3l='i3lock -c 000000'
a 3il='i3l'
a sx=startx

# sdcv
a define=sdcv
a defin=sdcv
a defi=sdcv
a def=sdcv
a dic=sdcv
a dictionary=sdcv
a dict=sdcv

# cd
a dot='cd ~/.dotfiles'
a sdcard='cd /sdcard; ls;'
a down='cd ~/Downloads; ls'
a drop='cd ~/Dropbox; ls'
a cdpico="cd ~/.lexaloffle/pico-8/carts"
a cv="cd ~/.config/nvim"
a c='cd'
a c-='cd -'
a c~='cd;cd' # Example: `c~ .dotfiles` will open '~/.dotfiles'.
a c.='cd ..'
a sand='cd ~/repos/sand'

# clear
a cl=clear

# xclip
a copycurrent='echo cd $(pwd) | xclip'
a copypath=copycurrent

# make
a ake=make
a maake=make
a kmake=make
a jake=make
a jmake=make
a maek=make
a mak=make
a mkae=make
a mkea=make
a amke=make

# exit
a xeit='exit'
a quit='exit'
a eitx='exit'
a eixt='exit'
a etix='exit'
a etxi='exit'
a exti='exit'
a xite='exit'
a xit='exit'
a ext='exit'
a xti='exit'

# sbri
sbri() { echo $(expr $1 \* 192) > /sys/class/backlight/intel_backlight/brightness }
a supbri="sbri 100"
a mid="sbri 50"
a dim="sbri 20"
a bri="sbri 80"
a morbri="sbri 90"
a mordim="sbri 10"
a supdim="sbri 1"

# localectl & setxkbmap
a cdv='localectl set-keymap --no-convert dvorak'
a cqw='localectl set-keymap --no-convert us'
a gdv='killall sxhkd keynav; setxkbmap -layout "us" -variant "dvorak"; (keynav &; sxhkd &)'
a gqw='killall sxhkd keynav; setxkbmap -layout "us"; (keynav &; sxhkd &)'

# ls
a ls='exa'
a l='ls'
a lst='exa --tree'
a lt='lst'
a lls='ls'
a lss='ls'
a sl='ls'
a la='ls -a'
a lsa='ls -a'
a ll='ls -l'
a l.='ls -d .*'
a lsla='ls -la'
a lla='ls -la'
a lsl='ls -l'
a sls='ls -l'
a ssl='ls -l'
a ls..="ls .."

# poweroff
a poweraff='poweroff'
a pwoeroff='poweroff'
a pworeoff='poweroff'
a powreoff='poweroff'
a oweroff='poweroff'

# w3m
a w3m='w3m -no-mouse'
ddg() {
    w3m ddg.gg?q=$(urlencodeplus "${@:-}")
}

# xrandr
a tolap="xrandr --output HDMI-1 --off --output eDP-1 --auto --mode 1366x768 --panning 1366x768"
a tomirror="xrandr --output HDMI-1 --mode 1366x768 --output eDP-1 --same-as HDMI-1"

# feh
a feh='feh --force-aliasing --scale-down'
a rndbkgd="feh --randomize --bg-fill ~/Pictures/photos/*"
a difbkgd="rndbkgd"

# zathura
a zath=zathura
a z=zathura

# systemctl
a renet='systemctl restart NetworkManager.service'
a printer='systemctl start org.cups.cupsd'
a nonet='systemctl stop NetworkManager.service'
a netman='systemctl start NetworkManager.service'
a noprinter='systemctl stop org.cups.cupsd'

# pico8
a p8tool='~/repos/picotool/p8tool'
a pico="pico8"

# rm
a rmrf="rm -rf"
a rmr="rm -r"
a rd="rmdir"

# pass
a pe='pass edit'

# synclient
a mouse='synclient TouchpadOff=0'
a nomouse='synclient TouchpadOff=1'

# sudo
a psudo='sudo env "PATH=$PATH" '
a sudo='sudo '

# publish
a listchinesefonts='fc-list :lang=zh'
a markdowntopdf='pandoc --pdf-engine=xelatex -V CJKmainfont="Source Han Sans CN" -o' # outputfile then input file.
viewmarkdown() { md2html $1 | qutepipe }
a vm='viewmarkdown'
a qb='qutebrowser'

# concards
a cards="cd ~/sync/alan/diary/cards"
a ca="cards"
a cnc="concards ~/sync/alan/diary"

# list things for fzf
_fzf_compgen_path() { fd -t f -t d . "$1" }
export FZF_DEFAULT_OPTS='--height 40% --reverse'

# xargs
a xargs='xargs '
a x='xargs '

trim() { awk '{gsub(/^ +| +$/,"")}{print}' }

# My hacky way to make a video 2x speed.
# vidspeed <input-file> <output-file>
doublespeed() {
    mencoder -speed 2 -o ".tmp-$2" -oac pcm -ovc lavc "$1"
    ffmpeg -vn -i ".tmp-$2" ".tmp-old-$2.wav"
    sox ".tmp-old-$2.wav" ".tmp-$2.wav" pitch -1200
    mencoder -ovc copy -oac copy -audiofile ".tmp-$2.wav" ".tmp-$2" -o "$2"
    rm ".tmp-old-$2.wav" ".tmp-$2" ".tmp-$2.wav"
}

# pico8 workflow commands
a pc="pico-compile"
a pw="pico-watch"

# gpg
# gpg, manage email:         gpg --edit-key X; adduid; list; uid X; trust; uid X; revuid; save
# gpg, create subkey:        gpg --edit-key X; addkey (4, 4096); save;
# transfer subkey w/ssh:     gpg --export-secret-subkeys X! | ssh X -C 'gpg --import' # exclamation mark forces subkey.
# transfer all public w/ssh: gpg --armor --export X | ssh X -C 'gpg --import'
# import: gpg --import
# view info about key: gpg --list-packets

gpg-send-private() {
    [ "$#" -ne 2 ] && echo "USAGE: $0 <gpg-key-hash> <ssh-profile>" && return 1
    (pass show gpg 2>/dev/null; gpg --export-secret-subkeys "$1!") | ssh "$2" gpg --import --pinentry-mode loopback --passphrase-fd 0
}

gpg-send-public() {
    [ "$#" -ne 2 ] && echo "USAGE: $0 <gpg-key-hash> <ssh-profile>" && return 1
    (pass show gpg 2>/dev/null; gpg --armor --export "$1") | ssh "$2" gpg --import --pinentry-mode loopback --passphrase-fd 0
}

a gpglk='gpg --list-keys --with-subkey-fingerprints --with-keygrip'
a gpgek='gpg --armor --export'
a gpgfgk='gpg --full-generate-key'

# rg
fnam() { local filename=$(basename -- $1); echo "${filename%.*}"; }
enam() { local filename=$(basename -- $1); echo $([[ "$filename" = *.* ]] && echo ".${filename##*.}" || echo ''); }

a rgl='rg -l'
a rgc='rg --color always'
rr() { rg "$1" "${@:3}" -l | xargs sed -Ei "s^$1^$2^g" }
rgf() { rg "$1"; fd -t f -s "$1" }

# Mv a file local to its directory.
rmv() { mv "$1" "$(dirname $1)/$2" }
rcp() { cp $1 "$(dirname $1)/$2" } # Cp a file local to its directory.
sw() { tf=$(mktemp $(dirname "$1")/XXXXXX) && mv "$1" "$tf" && mv "$2" "$1" &&  mv "$tf" "$2" }

# Networking Notes
# find which domain names are used for an IP with "nslookup"

# human readable flags
a free='free -h'
a du='du -h'
a df='df -h'

# random
ssht() { ssh $1 -t 'tmux attach 2> /dev/null || tmux 2> /dev/null || zsh 2> /dev/null || bash 2> /dev/null' "${@:2}" }
ttt() { [[ -n $1 ]] && while sleep 1s; do (ttrack rec "$1" 2s &); done || echo 'Requires argument for group' }

a wh=which
a termdown='termdown -a --font 3x5'
a tt='ttrack'
a bat='bat -p --paging never'
a b='bat'
a u='echo -e "$(whoami)@$(hostname)"'
a bn='basename'
a p='pwd'
a wai=whoami
a lam='lookatme --live -e terminal'
a pipi='pip install --user'
a bc='bc -q'
a dd='dd status=progress'
a emacs='emacs -nw'
a fb="~/repos/fuzzybird/fuzzybird.py --hashtag"
a int='sudo wifi-menu'
a lid="echo locked > '/tmp/.lid-lock-file'"
a lock="physlock"
a pavucontrol="ncpamixer"
a pinger='ping www.google.com'
a renginx="sudo nginx -s reload"
a r='ranger'
a ta='tmux attach'
a updatexterm='xrdb merge ~/.Xresources'
a watch='watch -c -d'
a daet='date'
a slblk='lsblk'
a repinyin='repelify pinyin'

# himalaya archive inbox
emailarchive() {
    last=$(himalaya -a "$1" -o json list -s 1 | jq -r '.response[].id')
    [[ -n $last ]] && himalaya -a "$1" move "1:$last" "$2"
}

a garch='emailarchive gmail "[Gmail]/All Mail"'
a xarch='emailarchive xoc3  All'

# Turns any command into a repl!
repelify() {
    if [[ -z $1 ]]; then echo 'No command provided'; return; fi
    printf '-> '
    while read -r line; do
        cat <<< "$line" | $*
        printf '-> '
    done
}

printnotnil() { [[ -n "${@:2}" ]] && cat <<< ${1/\%\%/${@:2}} }

fzf_echo_all_dirs()    { printnotnil '%%' $(fd -IHt d | fzf -m) }
fzf_echo_all_files()   { printnotnil '%%' $(fd -IHt f -t l | fzf -m) }
fzf_echo_dirs()        { printnotnil '%%' $(fd -t d | fzf -m) }
fzf_echo_emoji()       { printnotnil '%%' $(emoji-fzf preview | fzf -m --with-nth 2.. -d ' ' | awk '{print $1;}' | emoji-fzf get) }
fzf_echo_files()       { printnotnil '%%' $(fd -t f -t l | fzf -m) }
fzf_echo_git_branch()  { printnotnil '%%' $(git for-each-ref --format='%(refname:short)' refs/remotes refs/heads | fzf -m) }
fzf_echo_git_refs()    { printnotnil '%%' $(git for-each-ref --format='%(refname:short)' | fzf -m) }
fzf_echo_git_tag()     { printnotnil '%%' $(git for-each-ref --format='%(refname:short)' refs/tags | fzf -m) }
fzf_echo_history()     { printnotnil '%%' $(fc -rl 1 | fzf --tiebreak=index --nth 2.. | sed -E 's/^ *[0-9]+ *//g') }
fzf_echo_man()         { printnotnil '%%' $(apropos "." 2> /dev/null | awk '{print $1;}' | uniq | fzf) }
fzf_echo_pass()        { printnotnil '%%' $(fd --base-directory ~/.password-store -t f | rg '\.gpg$' | sed -E 's/\.gpg$//g' | fzf) }
fzf_echo_ssh()         { printnotnil '%%' $(sed -rn 's/^\s*Host\s+(.*)$/\1/ip' ~/.ssh/config ~/.ssh/local_ssh 2> /dev/null | xargs -n1 | fzf -m) }
fzf_echo_tmux_tokens() { printnotnil '%%' $(tsl | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=ctrl-z:ignore $FZF_DEFAULT_OPTS" fzf -m "$@" | tr '\n' ' ' | awk '{gsub(/ +$/,"")}{print}') }
fzf_echo_ttrack()      { printnotnil '%%' $(ttrack ls -r | fzf -m) }
fzf_echo_himalaya_account() { cat ~/.config/himalaya/config.toml | rg '^\[(.+)\]$' -r '$1' | fzf --bind space:accept }

fzf_echo_himalaya_mbox() {
    local ACCOUNT=${1:-$(fzf_echo_himalaya_account)}
    [[ -n $ACCOUNT ]] || exit
    himalaya -a $ACCOUNT -o json mboxes | jq '.response | map(.name)[]' -r | fzf
}

fzf_echo_himalaya_id() {
    local ACCOUNT=${1:-$(fzf_echo_himalaya_account)}
    [[ -n $ACCOUNT ]] || exit
    local MBOX=${2:-$(fzf_echo_himalaya_mbox $ACCOUNT)}
    [[ -n $MBOX ]] || exit
    himalaya -a "$ACCOUNT" -m "$MBOX" -o json list | jq '.response | map((if (.flags | length) > 0 then "  " else "* " end) + (.id|tostring) + " - " + .sender + " - " + .subject)[]' -r | fzf | rg '^..(\d+).+$' -r '$1'
}

fzf_eval_himalaya_read() {
    local ACCOUNT=$(fzf_echo_himalaya_account)
    [[ -n $ACCOUNT ]] || exit
    local MBOX=$(fzf_echo_himalaya_mbox $ACCOUNT)
    [[ -n $MBOX ]] || exit
    local ID=$(fzf_echo_himalaya_id $ACCOUNT $MBOX)
    [[ -n $ID ]] || exit
    cat <<< "himalaya -a '$ACCOUNT' -m '$MBOX' read '$ID'"
}

# transfer.sh
transfer(){ if [ $# -eq 0 ];then echo "No arguments specified.\nUsage:\n transfer <file|directory>\n ... | transfer <file_name>">&2;return 1;fi;if tty -s;then file="$1";file_name=$(basename "$file");if [ ! -e "$file" ];then echo "$file: No such file or directory">&2;return 1;fi;if [ -d "$file" ];then file_name="$file_name.zip" ,;(cd "$file"&&zip -r -q - .)|curl -s --upload-file "-" "https://transfer.sh/$file_name"|tee /dev/null,;else cat "$file"|curl -s --upload-file "-" "https://transfer.sh/$file_name"|tee /dev/null;fi;else file_name=$1;curl -s --upload-file "-" "https://transfer.sh/$file_name"|tee /dev/null;fi;}

fzf_eval_bat()     { printnotnil 'bat %%'                            $(fzf_echo_files) }
fzf_eval_cat()     { printnotnil 'cat %%'                            $(fzf_echo_files) }
fzf_eval_cd()      { printnotnil 'cd %% && pwd'                      $(fd -t d | fzf) }
fzf_eval_history() { printnotnil '%%'                                $(fzf_echo_history) }
fzf_eval_man()     { printnotnil 'man %%'                            $(fzf_echo_man) }
fzf_eval_pass()    { printnotnil 'pass show "%%" 2> /dev/null | perl -pe "chomp if eof" | ccl' $(fzf_echo_pass) }

fzf_eval_rg_kak() {
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
    RG_LINE=$(eval "$RG_PREFIX ''" | fzf --nth 3.. -d ':' --bind "change:reload:$RG_PREFIX {q} || true")
    FILE=$(cut -d ':' -f 1   <<< $RG_LINE)
    LINE=$(cut -d ':' -f 2   <<< $RG_LINE)
    COLUMN=$(cut -d ':' -f 3 <<< $RG_LINE)

    printnotnil "kak \"%%\" +$LINE:$COLUMN" "$FILE"
}

fzf_gui_copy_file()  { cd $HOME; output=$(fzf_echo_files); [[ -n "$output" ]] && cat "$output" | ccl }
fzf_gui_pass()       { output=$(fzf_echo_pass); [[ -n "$output" ]] && echo "$output" | xargs pass show 2> /dev/null | perl -pe "chomp if eof" | ccl }
fzf_gui_qute()       { echo 'search for what?'; echo -n '' | fzf --no-info --print-query --height 1 | read search; [[ -n "$search" ]] && qutebrowser "$search" & }
fzf_gui_exec()       { VAL=$(echo "$PATH" | tr : '\0' | xargs -0 fd . --exact-depth 1 2>/dev/null | sed -E 's,.+/,,g' | sort -u | fzf); [[ -n "$VAL" ]] && setsid "$VAL" & }

fzf_echo_modes() { eval $(printnotnil '%%' ${1:-$(print -l ${(ok)functions} | rg '^fzf_echo_' | sed -E 's/_/ /g' | fzf --bind space:accept --with-nth 3.. -d ' ' | sed -E 's/ /_/g')}) }
fzf_eval_modes() { eval $(printnotnil '%%' ${1:-$(print -l ${(ok)functions} | rg '^fzf_eval_' | sed -E 's/_/ /g' | fzf --bind space:accept --with-nth 3.. -d ' ' | sed -E 's/ /_/g')}) }
fzf_gui_modes()  { eval $(print -l ${(ok)functions} | rg '^fzf_gui_'  | sed -E 's/_/ /g' | fzf --height 100% --bind space:accept --with-nth 3.. -d ' ' | sed -E 's/ /_/g'); exit }

# Creates a hash of all your arguments. This is guaranteed to be unique
argshash() { for arg in "$@"; do sha256sum <<< "$arg"; done | sha256sum | awk '{print $1;}' }

# If a command was run recently, just cat the cache file. If not recent, run the command.
# Duration defaults to days, but can have other time endings too: smhdw
# cachemd DURATION CMD ARGS...
cachecmd() {
    CACHE_DIR=${CACHECMD_DIR:-${XDG_CACHE_HOME:-/tmp}}/cachecmd
    DURATION=$1
    FILE=${CACHE_DIR}/$(argshash "${@:2}")

    if [[ $(find $FILE -mtime -${DURATION} 2>/dev/null) ]] && [[ -z "$CACHECMD_CLEAR" ]]; then
        [[ -n "$CACHECMD_DEBUG" ]] && echo '[cachecmd] cache mode' >&2
        cat < "$FILE"
    else
        [[ -n "$CACHECMD_DEBUG" ]] && echo '[cachecmd] command mode' >&2
        mkdir -p "$CACHE_DIR"
        "${@:2}" | tee "$FILE"
    fi
}

# # Proof of concept for cachecmd with ax shell.
# a cachecmd ^EOF
#     $CACHE_DIR [!if (test -n {CACHECMD_DIR}) {CACHCMD_DIR} [!if (test -n {XDG_CACHE_HOME}) {XDG_CACHE_HOME} -/tmp]]/cachecmd
#     $CACHE_DIR [or {CACHECMD_DIR} {XDG_CACHE_HOME} /tmp]/cachecmd
#     $DURATION {1}
#     $FILE {CACHE_DIR}/(argshash *[range '2:' *{@}])
# 
#     !if (!and (find {FILE} -mtime -{DURATION} 2>/dev/null) (test -z {CACHECMD_CLEAR}))
#         [
#             (!if (test -n {CACHECMD_DEBUG}) [echo '[cachecmd] cache mode'])
#             cat -- {FILE}
#         ][
#             (!if (test -n {CACHECMD_DEBUG}) [echo '[cachecmd] command mode'])
#             mkdir -p {CACHE_DIR}
#             [range '2:' *{@}] | tee {FILE}
#         ];
# EOF
